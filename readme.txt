Project 2 readme.txt
CS61BL Section 110
GSI: Doug
Anastasia Shuler    cs61bl-nl
Iris Jang           cs61bl-ni
Ji-hern Baek        cs61bl-nj
Katherine Chao      cs61bl-no

Testing:
    

Contributions:
Anastasia was responsible for the ProofTree class, and, in extension, the Expression class. These two classes go hand-in-hand: an Expression object stores a ProofTree object as one of its fields. The Expression class's main function is to store information about an expression, both as a string and as a ProofTree. ProofTree's main function is to create and manipulate arithmetic trees formed from the user-inputed expressions. ProofTree contains methods to create, print, and perform tests upon an expression (given as a string). ProofTree additionally deals with theorem checking, another task Anastasia was responsible for. The isSimilar() method of the ProofTree class checks that a theorem application adheres to the proper form and syntax of the expressions given in the theoremSet. isSimilar() checks that all operators of a potential theorem application match those of the theorem, and that each of the theorem variables correspond to exactly one unique expression in the user supplied expression. Finally, Anastasia implemented the Inference class, which contains methods for checking the validity of all inferences made by the user. This includes the ic, mp, mt, and co inferences as well as the 'assume' statements. All of these checks rely heavily on the work done in the ProofTree class, and use ProofTrees for basic pattern matching and syntax checking.

Katherine was responsible for a large part of the Proof class (parts of extendProof and the toString() and isComplete() methods, and the setup of the instance variables), the LineNumber class, and some of the Format class and tests. The LineNumber class uses an array representation to store each layer of the line number as indexes in the array. The toString() method in Proof iterates through an ArrayList of stored line numbers, which were then retreived from a Hashtable that related line numbers and user input. The isComplete() method checks the beginning and last expressions of the proof to see if they're equal, which returns true if they are and false if they aren't, barring certain special circumstances. She also dealt with the throwing/handling of exceptions in checkFormat() in the Format class and implemented the format checker in extendProof.

Ji-hern Baek and Iris Jang implemented both parsing and the user input validity checking through Format, which is called by Proof upon user input. Format first checks the overall format of the whole input (e.g. “mp” input must have four sections: mp, [line number], [line number], and [line number].) If the input passes the overall format check, the expression section of the input is actually parsed. Format first checks for edge cases, such as ~p. It also filters out inputs that clearly used wrong characters, or contained spaces in the middle of the expression. During the bulk of parsing, Iris derived a way to check that parentheses are balanced, and to check the validity of each subexpression, by keeping track of the subexpression “level.”  Following Ji-hern’s idea, who devised the framework, Format derives the validity of the expression by exploring the relationship between each character in the overall string. Iris and Ji-hern used Junit tests and the debug mode of Eclipse to catch a plethora of cases, and to refine the code. Valid strings return true; else, an exception will be thrown.

Format's JUnits first test extreme edge cases, such as solely numeric inputs (“98”) or single letter inputs. It then tests many cases with parentheses, such as misplaced parentheses, excessive parentheses, and unbalanced parentheses. It also tests for “operators” - only one operator may be used within each subexpression. Furthermore, with the exception of not [expression] inputs, each valid expression must utilize two “variables” (which may be pattern matched - we tested that as well). It also tests an empty string, and would Junit have let us, we would have tested a null input. Generally, a large expression will have two “subexpressions”, connected by an operator (=>, | or &). 


