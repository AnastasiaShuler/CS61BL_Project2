Project 2 readme.txt
CS61BL Section 110
GSI: Doug
Anastasia Shuler    cs61bl-nl
Iris Jang           cs61bl-ni
Ji-hern Baek        cs61bl-nj
Katherine Chao      cs61bl-no

Testing:
Testing is mainly done through the use of Junit tests suites. Every class has a corresponding Junit file to ensure critical methods function as expected. The overall testing of the project happens in ProofTest.java. Here, we make 7 calls to external text files in order to test the entirity of the program. These 7 tests encompass the variety of problems that could cause the project to fail. We test proofs that utilize a theorem, as well as those that don't. Several of the proofs test incorrect input, which is all sucessfully delt with by Format.java. We additionally test the incorrect usage of inference statements, and all such errors are delt with by the Inference class.
Junit tests for the other classes are designed to test for boundary conditions. The bulk of these tests reside in FormatTest.java, as the Format class is respnosible for the majority of syntax checking. Here, we made sure to test a variety of user inputs, including null strings, empty strings, illegal characters, and incorrect parenthesization of expressions.

ProofTreeTest.java focuses on testing the inner workings of the ProofTree class, ensuring that the methods function expected. The main methods tested are createATree() and printInOrder() methods. Many other methods rely on these two, so it was essential to ensure their correctness.

InferenceTest.java tests the methods for detecting errors in an assume, ic, mt, mp, or co statement. These methods rely on those in the ProofTree class, and much of the testing checks that known examples return the correct output.

For LineNumbertest, the testNext() method tests the incrementation of the index in the array every time next() is called. The addition of an array index (which happens when a new subproof begins) beginning at 1 and the subtraction of the index (which happens when the subproof is finished) is tested for as well. We also test the line decrementation method, prev(), with tests such as decrementing twice and making sure that if the last index of the array is 1, it doesn't decrement because a last index of 0 isn't valid.  The testReferences() method tests the isValidReference() method in LineNumber, which implements the rules for a legal line reference, such as testing that the line being referenced exists in the proof, that the reference isn't apart of an inner subproof that the current line isn't apart of, and that if the reference is in the same subproof, whether all indexes except for the very last are equal. If any of these are violated, the isValidReference() method will return false.

TheoremSet does not have it's own test file, as the only method to be tested is the theoremChecker() method, and that is a simple call to the isSimilar() method of the ProofTree class (which is tested itself in ProofTreeTest.java).

Contributions:
Anastasia was responsible for the ProofTree class, and, in extension, the Expression class. These two classes go hand-in-hand: an Expression object stores a ProofTree object as one of its fields. The Expression class's main function is to store information about an expression, both as a string and as a ProofTree. ProofTree's main function is to create and manipulate arithmetic trees formed from the user-inputed expressions. ProofTree contains methods to create, print, and perform tests upon an expression (given as a string). ProofTree additionally deals with theorem checking, another task Anastasia was responsible for. The isSimilar() method of the ProofTree class checks that a theorem application adheres to the proper form and syntax of the expressions given in the theoremSet. isSimilar() checks that all operators of a potential theorem application match those of the theorem, and that each of the theorem variables correspond to exactly one unique expression in the user supplied expression. Finally, Anastasia implemented the Inference class, which contains methods for checking the validity of all inferences made by the user. This includes the ic, mp, mt, and co inferences as well as the 'assume' statements. All of these checks rely heavily on the work done in the ProofTree class, and use ProofTrees for basic pattern matching and syntax checking.

Katherine was responsible for a large part of the Proof class (parts of extendProof and the toString() and isComplete() methods, and the setup of the instance variables), the LineNumber class, and some of the Format class and tests. The LineNumber class uses an array representation to store each layer of the line number as indexes in the array. The toString() method in Proof iterates through an ArrayList of stored line numbers, which were then retreived from a Hashtable that related line numbers and user input. The isComplete() method checks the beginning and last expressions of the proof to see if they're equal, which returns true if they are and false if they aren't, barring certain special circumstances. She also dealt with the throwing/handling of exceptions in checkFormat() in the Format class and implemented the format checker in extendProof.

Ji-hern Baek and Iris Jang implemented both parsing and the user input validity checking through Format, which is called by Proof upon user input. Format first checks the overall format of the whole input (e.g. “mp” input must have four sections: mp, [line number], [line number], and [line number].) If the input passes the overall format check, the expression section of the input is actually parsed. Format first checks for edge cases, such as ~p. It also filters out inputs that clearly used wrong characters, or contained spaces in the middle of the expression. During the bulk of parsing, Iris derived a way to check that parentheses are balanced, and to check the validity of each subexpression, by keeping track of the subexpression “level.”  Following Ji-hern’s idea, who devised the framework, Format derives the validity of the expression by exploring the relationship between each character in the overall string. Iris and Ji-hern used Junit tests and the debug mode of Eclipse to catch a plethora of cases, and to refine the code. Valid strings return true; else, an exception will be thrown.

Format's JUnits first test extreme edge cases, such as solely numeric inputs (“98”) or single letter inputs. It then tests many cases with parentheses, such as misplaced parentheses, excessive parentheses, and unbalanced parentheses. It also tests for “operators” - only one operator may be used within each subexpression. Furthermore, with the exception of not [expression] inputs, each valid expression must utilize two “variables” (which may be pattern matched - we tested that as well). It also tests an empty string, and would Junit have let us, we would have tested a null input. Generally, a large expression will have two “subexpressions”, connected by an operator (=>, | or &). 


