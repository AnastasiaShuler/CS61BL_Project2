Project 2 readme.txt
CS61BL Section 110
GSI: Doug
Anastasia Shuler    cs61bl-nl
Iris Jang           cs61bl-ni
Ji-hern Baek        cs61bl-nj
Katherine Chao      cs61bl-no

Testing:
LineNumberTest
The testNext() method tests the incrementation of the index in the array every time next() is called. The line decrementation method, prev(), is also tested for. The addition of an array index (which happens when a new subproof begins) beginning at 1 and the subtraction of the index (which happens when the subproof is finished) is tested for as well. The testReferences() method tests the isValidReference() method in LineNumber, which implements the rules for a legal line reference, such as testing that the line being referenced exists in the proof, that the reference isn't apart of an inner subproof that the current line isn't apart of, and that if the reference is in the same subproof, whether all indexes except for the very last are equal. If any of these are violated, the isValidReference() method will return false.
    

Contributions:
Anastasia was responsible for the ProofTree class, and, in extension, the Expression class. These two classes go hand-in-hand: an Expression object stores a ProofTree object as one of its fields. The Expression class's main function is to store information about an expression, both as a string and as a ProofTree. ProofTree's main function is to create and manipulate arithmetic trees formed from the user-inputed expressions. ProofTree contains methods to create, print, and perform tests upon an expressoin (given as a string). ProofTree additionally deals with theorem checking, another task Anastasia was responsible for. The isSimilar() method of the ProofTree class checks that a theorem application adheres to the proper form and syntax of the expressions given in the theoremSet. isSimilar() checks that all operators of a potential theorem application match those of the theorem, and that each of the theorem variables coorespond to exactly one unique expression in the user supplied expression. Finally, Anastasia implemented the Inference class, which contains methods for checking the validity of all inferences made by the user. This includes the ic, mp, mt, and co inferences as well as the 'assume' statements. All of these checks rely heavily on the work done in the ProofTree class, and use ProofTrees for basic pattern matching and syntax checking.

Katherine was responsible for a large part of the Proof class (parts of extendProof and the toString() and isComplete() methods, and the setup of the instance variables), the LineNumber class, and some of the Format class and tests. The LineNumber class uses an array representation to store each layer of the line number as indexes in the array. The toString() method in Proof iterates through an ArrayList of stored line numbers, which were then retreived from a Hashtable that related line numbers and user input. The isComplete() method checks the beginning and last expressions of the proof to see if they're equal, which returns true if they are and false if they aren't, barring certain special circumstances. She also dealt with the throwing/handling of exceptions in checkFormat() in the Format class and implemented the format checker in extendProof.

Iris and Ji-hern were responsible for Format and FormatTest.java; the former creating the final layout of the code, and the latter developing the idea and creating the framework. The idea behind Format.java was to make sure we could check the validity of an expression before actually parsing it (as that was how our project dealt with the different lines). Checking the validity of an expression included sending in lines into the class. We would split the lines based on line numbers, key words, and expressions. As such, we would first check that format of each met the requirements listed in the class. The difficult part came when we attempted to check the validity of the expression. We had to check each individual character, ensuring that paranethese were all properly placed, no invalid characters were in the expression, and that, when analyzing a character, the characters before and after were acceptable. We also had to check for certain special cases i.e. parenthese right next to each other, subsequent variables, etc. We then checked each case in our format test.
